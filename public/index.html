<!DOCTYPE html>
<html>
  <head>
    <title>Leseki:ds</title>
    <script src="jspsych/dist/jspsych.js"></script>
    <script src="jspsych/dist/plugin-html-button-response.js"></script>
	<script src="jspsych/dist/plugin-survey-text.js"></script>
	<script src="js/items.js"></script>
	<script src="js/item-selection.js"></script>
	<script src="js/utils.js"></script>
	<script src="js/api.js"></script>
	<script src="js/score.js"></script>
	<script src="js/tts.js"></script>
    <link rel="stylesheet" href="jspsych/dist/jspsych.css" /> 
	<link rel="stylesheet" href="css/text-container.css"></style>
	<link rel="stylesheet" href="css/tooltip.css"></style>
  </head>


  <body>
    <script>

const jsPsych = initJsPsych({
experiment_width: 750,
        show_progress_bar: false,
  on_close: function () { 
    fetch("/api/save", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(jsPsych.data.get().values())
    })
    .then(response => {
      if (!response.ok) throw new Error("Fehler beim Speichern");
      return response.text();
    })
    .then(msg => {
      console.log(" Erfolgreich gespeichert:", msg);
    })
    .catch(error => {
      console.error(" Fehler beim Speichern:", error);
    });
  }, 
  on_finish: () => jsPsych.data.displayData("json")
      });
const items = window.items;
/// Parameters 
const ITEMS_PER_SESSION = 7;
let thetaRes = { theta: 0, se: 0.8 }
//console.log("Das ist das ausgangsniveau", thetaRes.theta );
/// Function for sampling


function getSubjectIdFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get("id") || jsPsych.randomization.randomInt(100000000,999999999); // fallback
};

const subject_id = getSubjectIdFromURL();

jsPsych.data.addProperties({subject_id: subject_id});


      let totalPoints = 0;
      let tasksCompleted = 0;
      let scoredItems = [];


async function start() {
  const subject_id = getSubjectIdFromURL();
  jsPsych.data.addProperties({ subject_id });

  // Beide Requests parallel laden
  const [summary, thetaData, completedItems, paramsMap] = await Promise.all([
    loadSubjectSummary(subject_id),
    loadTheta(subject_id),
    loadCompletedItems(subject_id),
	loadItemParams()
  ]);

  // ‚ùó sichere Defaults, falls thetaData = null ist
  const theta = (thetaData && typeof thetaData.theta === "number") ? thetaData.theta : 0;
  const thetaSE = (thetaData && typeof thetaData.se === "number") ? thetaData.se : 2;

  console.log("Mit diesem theta werden die Items ausgew√§hlt:", theta);

  // Remaining + gewichtete Auswahl
  const DEFAULTS = {
  threshold_1: -1,
  threshold_2: 0,
  first_threshold: 2000,
  points_first_try: 60,
  points_later_try: 40,
  weight: 1
};
  const itemsWithParams = items.map(it => ({ ...DEFAULTS, ...it, ...(paramsMap[it.item] || {}) }));
  const remainingItems = itemsWithParams.filter(item => !completedItems.includes(item.item));
  const weights = remainingItems.map(item => normalPDF(item.threshold_2, theta, 1));
  const selectedItems = weightedSampleWithoutReplacement(
    remainingItems,
    weights,
    Math.min(ITEMS_PER_SESSION, remainingItems.length)
  );

  const today = new Date().toISOString().slice(0, 10);
  const alreadyDoneToday = summary && summary.last_entry_date === today;

  const thetaLine = (thetaData && thetaData.theta != null)
    ? `<li><b>F√§higkeit (Œ∏):</b> ${thetaData.theta} <small>(SE ${thetaData.se})</small></li>`
    : `<li><i>Noch keine verl√§ssliche Œ∏-Sch√§tzung verf√ºgbar.</i></li>`;

  const summaryBlock = summary
    ? `
      <li><b>Gesamtpunkte:</b> ${summary.total_points}</li>
      <li><b>Bearbeitete Tage:</b> ${summary.days_with_entries}</li>
      <li><b>Zuletzt aktiv:</b> ${summary.last_entry_date}</li>
      <li><b>Aufgaben bearbeitet:</b> ${summary.num_tasks_completed}</li>`
    : `<li><i>Keine bisherigen Ergebnisse.</i></li>`;

  if (alreadyDoneToday) {
    const blockTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => `
        <h2>Hallo, ${subject_id}</h2>
        <p><b>Du hast heute bereits Aufgaben bearbeitet.</b></p>
        <p>Bitte versuche es morgen erneut.</p>
        <hr />
        <p>Bisherige Ergebnisse:</p>
     <ul>
        ${summaryBlock}
        ${thetaLine}
      </ul>
      `,
      choices: ["OK"],
	      on_finish: function (data) {
      data.stimulus = -9;
    },
    data: { type: 0 }
    };

    jsPsych.run([blockTrial]);
    return; // ‚õîÔ∏è Test nicht fortsetzen
  }

if (remainingItems.length === 0) {
    const finishedAll = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <h2>Super, ${subject_id}!</h2>
        <p>Du hast bereits alle verf√ºgbaren Aufgaben erfolgreich bearbeitet.</p>
		     <ul>
        ${summaryBlock}
        ${thetaLine}
      </ul>
      `,
      choices: ["OK"]
    };
    jsPsych.run([finishedAll]);
    return;
  }

  // Startseite vor dem eigentlichen Test
const startTrial = {
    type: jsPsychHtmlButtonResponse,
    stimulus: () => {
      if (summary) {
        return `
          <h2>Willkommen, ${subject_id}</h2>
          <p>Bisherige Ergebnisse:</p>
          <ul>
            ${summaryBlock}
            ${thetaLine}
          </ul>
          <p>Klicke auf ‚ÄûStart‚Äú, um fortzufahren.</p>
        `;
      } else {
        return `
          <h2>Willkommen!</h2>
          <p>F√ºr <b>${subject_id}</b> liegen noch keine Eintr√§ge vor.</p>
          <ul>${thetaLine}</ul>
          <p>Klicke auf ‚ÄûStart‚Äú, um zu beginnen.</p>
        `;
      }
    },
    choices: ["Start"],
    on_finish: d => { d.stimulus = -1; },
    data: { type: 0 }
  };

  const main_timeline = [startTrial];
  
selectedItems.forEach((item) => {
  let repeats = 0;
  let selectedAlt = null;

  // Factory: erzeugt je nach Item-Typ das Frage-Trial
  function makeQuestionTrial(item) {
    const isOpen = item.type === "open";

    // Gemeinsamer Stimulus (mit TTS-Toolbar f√ºr que2a beim 2. Versuch)
    const stimulusHtml = function () {
      if (repeats === 0) {
        selectedAlt = null;
        return item.que;
      }
      if (!selectedAlt) selectedAlt = Math.random() < 0.5 ? "a" : "b";
      const html = selectedAlt === "a" ? item.que2a : item.que2b;

      if (selectedAlt === "a") {
        return `
          <div style="display:flex; gap:.5rem; align-items:center; margin-bottom:.5rem;">
            <button id="tts-play" ${ttsSupported() ? "" : "disabled"}>üîä Vorlesen</button>
            <button id="tts-stop" ${ttsSupported() ? "" : "disabled"}>‚èπÔ∏è Stop</button>
            ${ttsSupported() ? "" : "<small>(Text-to-Speech nicht unterst√ºtzt)</small>"}
          </div>
          <div id="tts-content">${html}</div>
        `;
      }
      return html;
    };

if (!isOpen) {
  const maxAttempts = 2;

  return {
    type: jsPsychHtmlButtonResponse,
    stimulus: stimulusHtml,
    choices: item.opt,
    data: {
      type: 1,
      item: item.item,
      correct_response: item.cor,
      question_type: "mc"
    },
    on_load: function () {
      if (repeats > 0 && selectedAlt === "a") {
        const playBtn = document.getElementById("tts-play");
        const stopBtn = document.getElementById("tts-stop");
        if (playBtn) {
          playBtn.addEventListener("click", () => {
            if (item.tts_text_que2a) {
              const u = new SpeechSynthesisUtterance(item.tts_text_que2a);
              u.lang = "de-DE"; u.rate = 1;
              window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
            } else {
              const content = document.getElementById("tts-content");
              ttsSpeakFromElement(content, { lang: "de-DE" });
            }
          });
        }
        if (stopBtn) stopBtn.addEventListener("click", () => ttsStop());
      }
    },
    on_finish: function (data) {
      ttsStop();

      const threshold = repeats === 0 ? item.first_threshold : 1000;
      data.rt_fast = data.rt < threshold;
	  
      const idx = Number.isFinite(parseInt(data.response, 10)) ? parseInt(data.response, 10) : null; 
	  data.chosen_index = idx;
	  data.chosen_text  = (idx !== null && Array.isArray(item.opt)) ? item.opt[idx] : null;
	  
	  data.fb_array = Array.isArray(item.fb) ? item.fb : null;
	  data.chosen_feedback = (data.fb_array && idx !== null) ? data.fb_array[idx] : null
	  
      data.correct = data.response == data.correct_response;
      data.repetition = repeats;

      // Scoring
      if (data.correct && !data.rt_fast) {
        if (repeats === 0) { data.score = 2; data.points_awarded = item.points_first_try; }
        else if (repeats === 1) { data.score = 1; data.points_awarded = item.points_later_try; }
        else { data.score = 0; data.points_awarded = 0; }
      } else {
        data.score = 0; data.points_awarded = 0;
      }
	  data.fb_array = Array.isArray(item.fb) ? item.fb : null;
	  data.chosen_feedback = (data.fb_array && Number.isInteger(data.chosen_index))
	  ? data.fb_array[data.chosen_index]
	  : null;


      // Versuchslogik (max. 2)
      if (!data.rt_fast && !data.correct) {
        repeats++;
        if (repeats >= maxAttempts) data.show_explain = true;
      }

      if (data.score > 0) {
        totalPoints += data.points_awarded;
        tasksCompleted++;
        scoredItems.push({
          thresholds: [item.threshold_1, item.threshold_2],
          score: data.score
        });
      }

      // Logging
      if (data.repetition === 0) {
        data.stimulus = -41;
      } else {
        data.stimulus = selectedAlt === "a" ? -42 : -43;
      }
      data.total_points = totalPoints;
      data.tasks_completed = tasksCompleted;
    }
  };
}


    // OPEN: Texteingabe √ºber survey-text
    return {
      type: jsPsychSurveyText,
      preamble: stimulusHtml,           // zeigt denselben HTML-Block wie oben
      questions: [
        { prompt: "", rows: 1, columns: 40, required: true, name: "ans", placeholder: "Deine Antwort" }
      ],
      button_label: "Antwort best√§tigen",
      data: {
        type: 1,
        item: item.item,
        question_type: "open"
      },
      on_load: function () {
        if (repeats > 0 && selectedAlt === "a") {
          const playBtn = document.getElementById("tts-play");
          const stopBtn = document.getElementById("tts-stop");
          if (playBtn) {
            playBtn.addEventListener("click", () => {
              if (item.tts_text_que2a) {
                const u = new SpeechSynthesisUtterance(item.tts_text_que2a);
                u.lang = "de-DE"; u.rate = 1;
                window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
              } else {
                const content = document.getElementById("tts-content");
                ttsSpeakFromElement(content, { lang: "de-DE" });
              }
            });
          }
          if (stopBtn) stopBtn.addEventListener("click", () => ttsStop());
        }
      },
      on_finish: async function (data) {
  ttsStop();

  const raw = data.response && (data.response.ans ?? data.response.Q0 ?? "");
  data.text_response = (raw ?? "").toString();

  const threshold = repeats === 0 ? item.first_threshold : 1000;
const wasCorrectBeforeScoring = false; 
  data.rt_fast = data.rt < threshold;
  data.repetition = repeats;
  
  console.log("üí° Starte LLM-Scoring f√ºr Item", item.item);
  // ‚Üê‚Äî NEU: Scoring via LLM (mit Fallback)
  const result = await scoreWithLLM({
    questionHtml: (repeats === 0 ? item.que : (selectedAlt === "a" ? item.que2a : item.que2b)),
    studentAnswer: data.text_response,
    item
  });

  data.llm_source = result.source;
  data.llm_rationale = result.rationale;
  data.normalized_answer = result.normalized_answer;

  data.correct = !!result.is_correct;

  // Punkte identisch zu vorher
  if (data.correct && !data.rt_fast) {
    if (repeats === 0) { data.score = 2; data.points_awarded = item.points_first_try; }
    else if (repeats === 1) { data.score = 1; data.points_awarded = item.points_later_try; }
    else { data.score = 0; data.points_awarded = 0; }
  } else {
    data.score = 0; data.points_awarded = 0;
  }

  // max. zwei Versuche -> Erkl√§rung
  const maxAttempts = 2;
  if (!data.rt_fast && !data.correct) {
    repeats++;
    if (repeats >= maxAttempts) data.show_explain = true;
  }

  if (data.score > 0) {
    totalPoints += data.points_awarded;
    tasksCompleted++;
    scoredItems.push({ thresholds: [item.threshold_1, item.threshold_2], score: data.score });
  }

  if (data.repetition === 0) { data.stimulus = -41; }
  else { data.stimulus = selectedAlt === "a" ? -42 : -43; }

  data.total_points = totalPoints;
  data.tasks_completed = tasksCompleted;
}
    };
  }

  const loop_node = {
    timeline: [
      makeQuestionTrial(item),
      {
  type: jsPsychHtmlButtonResponse,
stimulus: function () {
  const last = jsPsych.data.get().last(1).values()[0] || {};
  const isMC   = last.question_type === "mc";
  const isOpen = last.question_type === "open";

  // 1) Zu schnell
  if (last.rt_fast) {
    return `
      <p style="color:orange;">Halt, versuch dich nochmal zu konzentrieren.</p>
      <p>Bitte nimm dir Zeit, lies genau, und antworte erst dann.</p>
    `;
  }

  // Hilfsfunktion: Item-Objekt + explain holen
  const itemObj = items.find(i => i.item === last.item) || {};
  const explainHtml = itemObj.explain
    ? `<div class="div-2" style="margin-top:.5rem;">${itemObj.explain}</div>`
    : "";

  // 2) MC-Items
  if (isMC) {
    // a) Korrekt
    if (last.correct) {
      const fbText = last.chosen_feedback;
      const fbHtml = fbText
        ? `<div class="div-2">${(typeof escapeHtml === 'function' ? escapeHtml(fbText) : fbText)}</div>`
        : "";
      return `
        ${fbHtml}
        <p style="color:green;">Richtig! Du bekommst <b>${last.points_awarded}</b> Punkt(e).</p>
        <p>Gesamtpunktzahl: <b>${totalPoints}</b></p>
        <p>Erledigte Aufgaben: <b>${tasksCompleted} von ${selectedItems.length}</b></p>
      `;
    }

    // b) Nach zwei Fehlversuchen: richtige L√∂sung + explain anzeigen
    if (last.show_explain) {
      const corIdx = Number.isInteger(itemObj.cor) ? itemObj.cor : null;
      const correctText = (corIdx !== null && Array.isArray(itemObj.opt)) ? itemObj.opt[corIdx] : "‚Äî";
      return `
        <p style="color:red;">Das war leider nicht richtig.</p>
        <p>Die richtige Antwort ist: <b>${typeof escapeHtml === 'function' ? escapeHtml(correctText) : correctText}</b>.</p>
        ${explainHtml}
      `;
    }

    // c) Erster/zweiter Fehlversuch: optionsspezifisches Feedback
    const fbText = last.chosen_feedback;
    return fbText
      ? `<div class="div-2">${(typeof escapeHtml === 'function' ? escapeHtml(fbText) : fbText)}</div>
         <p style="color:red;">Versuch es gleich nochmal ‚Äì du erh√§ltst jetzt einen Tipp.</p>`
      : `<p style="color:red;">Leider falsch. Du bekommst jetzt einen Tipp.</p>`;
  }

  // 3) Offene Items
  if (isOpen) {
    const typed = last.text_response
      ? (typeof escapeHtml === 'function' ? escapeHtml(last.text_response) : last.text_response)
      : "";
    const rationale = (last.llm_rationale || "").trim();
    const rationaleHtml = rationale
      ? `<div class="div-2" style="margin-top:.5rem;"><small><i>Begr√ºndung (LLM): ${typeof escapeHtml === 'function' ? escapeHtml(rationale) : rationale}</i></small></div>`
      : "";

    // a) Korrekt
    if (last.correct) {
      return `
        <p style="color:green;">Richtig! Du bekommst <b>${last.points_awarded}</b> Punkt(e).</p>
        <p>Gesamtpunktzahl: <b>${totalPoints}</b></p>
        <p>Erledigte Aufgaben: <b>${tasksCompleted} von ${selectedItems.length}</b></p>
        ${rationaleHtml}
      `;
    }

    // b) Nach zwei Fehlversuchen: LLM-Rationale + explain zusammen anzeigen
    if (last.show_explain) {
      return `
        <p>Deine Antwort: ‚Äû${typed}‚Äú</p>
        <p style="color:red;">Das war leider nicht korrekt.</p>
        ${rationaleHtml}
        ${explainHtml}
      `;
    }

    // c) Erster Fehlversuch: nur kurze R√ºckmeldung + LLM-Begr√ºndung
    return `
      <p>Deine Antwort: ‚Äû${typed}‚Äú</p>
      <p style="color:red;">Das passt noch nicht. Du bekommst jetzt einen Tipp, versuch es anschlie√üend erneut.</p>
      ${rationaleHtml}
    `;
  }

  return `<p>Weiter</p>`;
},


  choices: ["Weiter"],
  on_finish: function (data) { data.stimulus = -2; },
  data: { type: 2 }
}],
loop_function: function () {
  const lastQuestion = jsPsych.data.get().last(2).values()[0]; // das Frage-Trial vor dem Feedback
  // Wiederhole nur, wenn NICHT (korrekt & nicht zu schnell) UND keine Erkl√§rung erzwungen wurde
  return !( (lastQuestion.correct && !lastQuestion.rt_fast) || lastQuestion.show_explain === true );
}
  };

  main_timeline.push(loop_node);
});
	  
const saveAndFetchTrial = {
  type: jsPsychHtmlButtonResponse,
  stimulus: `<p>Speichere ‚Ä¶</p>`,
  choices: [],
  on_load: async () => {
    try {
      await saveAllData();

      // kurz warten, damit die View aktualisiert ist
      await new Promise(r => setTimeout(r, 150));

      // bis zu 5x pollen
      let tries = 0;
      let s = null;
      while (tries < 5 && !s) {
        s = await loadSubjectSummary(subject_id); // gibt null wenn noch nix da
        if (!s) await new Promise(r => setTimeout(r, 200));
        tries++;
      }
      finalSummary = s;
      finalTheta   = await loadTheta(subject_id); // kann auch null sein
    } catch (e) {
      console.error("Save/Fetch-Fehler:", e);
      finalSummary = finalSummary ?? null;
      finalTheta   = finalTheta ?? null;
    } finally {
      jsPsych.finishTrial();
    }
  }
};

const endSummaryTrial = {
  type: jsPsychHtmlButtonResponse,
  stimulus: () => {
    const summaryBlock = finalSummary
      ? `
        <li><b>Gesamtpunkte:</b> ${finalSummary.total_points}</li>
        <li><b>Bearbeitete Tage:</b> ${finalSummary.days_with_entries}</li>
        <li><b>Zuletzt aktiv:</b> ${finalSummary.last_entry_date}</li>
        <li><b>Aufgaben bearbeitet:</b> ${finalSummary.num_tasks_completed}</li>`
      : `<li><i>Keine bisherigen Ergebnisse.</i></li>`;

    const thetaLine = (finalTheta && finalTheta.theta != null)
      ? `<li><b>F√§higkeit (Œ∏):</b> ${finalTheta.theta} <small>(SE ${finalTheta.se})</small></li>`
      : `<li><i>Noch keine verl√§ssliche Œ∏-Sch√§tzung verf√ºgbar.</i></li>`;

    return `
      <h2>Session beendet ‚Äì Zusammenfassung</h2>
      <ul>
        ${summaryBlock}
        ${thetaLine}
      </ul>
      <p>Danke dir! Du kannst das Fenster jetzt schlie√üen.</p>
    `;
  },
  choices: ["Fertig"]
};

main_timeline.push(saveAndFetchTrial, endSummaryTrial);
jsPsych.run(main_timeline);
}

start();






</script>
  </body>
</html>
