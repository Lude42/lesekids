// === file: public/admin/items.css ==========================================
.layout{display:grid;grid-template-columns:320px 1fr;gap:1rem}
.list{border-right:1px solid #e5e5e5;padding-right:1rem}
.list .search{display:flex;gap:.5rem;margin-bottom:.5rem}
.list ul{list-style:none;padding:0;margin:0;max-height:70vh;overflow:auto}
.list li{padding:.4rem .5rem;border-bottom:1px solid #f0f0f0;cursor:pointer}
.list li:hover{background:#fafafa}
.editor form{display:flex;flex-direction:column;gap:.6rem}
.row{display:flex;gap:.5rem;align-items:center}
.row label{min-width:140px}
.grid{display:grid;grid-template-columns:repeat(3,minmax(120px,1fr));gap:.6rem}
.flex{display:flex;gap:1.2rem}
.rte{min-height:120px;border:1px solid #ddd;border-radius:.5rem;padding:.5rem;background:#fff}
.toolbar{display:flex;gap:.4rem}
.hl-yellow{background:yellow}
.hl-green{background:#c1f2c7}
.hl-blue{background:#c9ddff}
.tt{position:relative;border-bottom:1px dotted #999;cursor:help}
.tt:hover::after{content:attr(data-tip);position:absolute;left:0;top:100%;white-space:pre-wrap;background:#333;color:#fff;padding:.3rem .5rem;border-radius:.3rem;font-size:.85rem;transform:translateY(4px);max-width:480px;z-index:10}
.div-note{background:#fff8db;border-left:4px solid #ffd43b;padding:.5rem;border-radius:.4rem}
.div-box{background:#f8f9fa;border:1px solid #dee2e6;padding:.6rem;border-radius:.4rem}
.div-hint{background:#e7f5ff;border-left:4px solid #74c0fc;padding:.5rem;border-radius:.4rem}
.actions{display:flex;gap:.5rem}


// === file: public/admin/items.js ===========================================
(async function(){
  const el = s => document.querySelector(s);
  const els = s => Array.from(document.querySelectorAll(s));
  const state = { currentId: null, current: null };

  // Toolbar actions for contenteditable
  function getRange(){
    const sel = window.getSelection();
    return sel && sel.rangeCount ? sel.getRangeAt(0) : null;
  }
  function wrapSelection(tag, cls){
    const range = getRange(); if (!range || range.collapsed) return;
    const span = document.createElement(tag);
    if (cls) span.className = cls;
    try { range.surroundContents(span); } catch { /* fallback */
      const frag = range.extractContents(); span.appendChild(frag); range.insertNode(span);
    }
  }
  function addTooltip(){
    const txt = prompt('Tooltip-Text eingeben:');
    if (!txt) return; const range = getRange(); if (!range || range.collapsed) return;
    const span = document.createElement('span'); span.className = 'tt'; span.setAttribute('data-tip', txt);
    try { range.surroundContents(span); } catch { const frag = range.extractContents(); span.appendChild(frag); range.insertNode(span); }
  }
  function insertDiv(cls){
    const r = getRange(); if (!r) return; const div = document.createElement('div'); div.className = cls; div.innerHTML = '<p>Neuer Block…</p>';
    r.collapse(false); r.insertNode(div); // after selection
  }

  function bindToolbar(){
    els('.toolbar [data-act]').forEach(btn => {
      btn.addEventListener('click', () => {
        const act = btn.getAttribute('data-act');
        if (act === 'hl-yellow') wrapSelection('span','hl-yellow');
        if (act === 'hl-green')  wrapSelection('span','hl-green');
        if (act === 'hl-blue')   wrapSelection('span','hl-blue');
        if (act === 'tooltip')   addTooltip();
        if (act === 'div-note')  insertDiv('div-note');
        if (act === 'div-box')   insertDiv('div-box');
        if (act === 'div-hint')  insertDiv('div-hint');
      });
    });
  }

  async function fetchList(){
    const q = el('#search').value.trim();
    const r = await fetch(`/api/admin/items?search=${encodeURIComponent(q)}`);
    const data = await r.json();
    const ul = el('#items'); ul.innerHTML = '';
    data.forEach(row => {
      const li = document.createElement('li');
      li.innerHTML = `<strong>#${row.item}</strong> <em>${row.type}</em><br><small>${(row.preview||'').replace(/</g,'&lt;').slice(0,140)}</small>`;
      li.addEventListener('click', () => loadItem(row.item));
      ul.appendChild(li);
    });
  }

  function clearEditor(){
    state.currentId = null; state.current = null;
    el('#f-item').value = '';
    el('#f-type').value = 'mc';
    el('#f-que').innerHTML = '';
    el('#f-que2a').innerHTML = '';
    el('#f-que2b').innerHTML = '';
    el('#f-correct').value = '';
    el('#f-options').innerHTML = '';
    el('#f-feedback').innerHTML = '';
    el('#f-t1').value = ''; el('#f-t2').value = ''; el('#f-ft').value = '';
    el('#f-p1').value = ''; el('#f-p2').value = ''; el('#f-w').value = '1';
    el('#f-tags').value = '';
    toggleMC(true);
  }

  function toggleMC(force){
    const isMC = (el('#f-type').value === 'mc');
    el('#mc-only').style.display = isMC ? '' : 'none';
  }

  function addLI(containerSel){
    const ol = el(containerSel); const li = document.createElement('li');
    li.innerHTML = `<div contenteditable class="rte"></div>`; ol.appendChild(li);
  }

  async function loadItem(id){
    const r = await fetch(`/api/admin/items/${id}`);
    if (!r.ok) { alert('Konnte Item nicht laden'); return; }
    const it = await r.json(); state.currentId = id; state.current = it;

    el('#f-item').value = it.item;
    el('#f-type').value = it.type; toggleMC();
    el('#f-que').innerHTML = it.que_html || '';
    el('#f-que2a').innerHTML = it.que2a_html || '';
    el('#f-que2b').innerHTML = it.que2b_html || '';
    el('#f-correct').value = Number.isInteger(it.correct_index) ? it.correct_index : '';

    const opt = Array.isArray(it.options) ? it.options : [];
    const fb  = Array.isArray(it.feedback) ? it.feedback : [];
    const olOpt = el('#f-options'); olOpt.innerHTML = '';
    const olFb  = el('#f-feedback'); olFb.innerHTML = '';
    opt.forEach(html => { const li=document.createElement('li'); li.innerHTML = `<div contenteditable class="rte">${html}</div>`; olOpt.appendChild(li); });
    fb.forEach(html  => { const li=document.createElement('li'); li.innerHTML = `<div contenteditable class="rte">${html}</div>`; olFb.appendChild(li); });

    el('#f-t1').value = it.threshold_1 ?? '';
    el('#f-t2').value = it.threshold_2 ?? '';
    el('#f-ft').value = it.first_threshold ?? '';
    el('#f-p1').value = it.points_first_try ?? '';
    el('#f-p2').value = it.points_later_try ?? '';
    el('#f-w').value  = it.weight ?? '1';
    el('#f-tags').value = it.tags || '';
  }

  async function save(){
    const body = {
      item: el('#f-item').value ? parseInt(el('#f-item').value,10) : undefined,
      type: el('#f-type').value,
      que_html: el('#f-que').innerHTML,
      que2a_html: el('#f-que2a').innerHTML,
      que2b_html: el('#f-que2b').innerHTML,
      options: els('#f-options .rte').map(d => d.innerHTML),
      correct_index: el('#f-correct').value === '' ? null : parseInt(el('#f-correct').value,10),
      feedback: els('#f-feedback .rte').map(d => d.innerHTML),
      threshold_1: parseFloat(el('#f-t1').value) || null,
      threshold_2: parseFloat(el('#f-t2').value) || null,
      first_threshold: parseInt(el('#f-ft').value,10) || null,
      points_first_try: parseInt(el('#f-p1').value,10) || null,
      points_later_try: parseInt(el('#f-p2').value,10) || null,
      weight: parseFloat(el('#f-w').value) || 1,
      tags: el('#f-tags').value || null,
    };

    const isUpdate = !!state.currentId;
    const url = isUpdate ? `/api/admin/items/${state.currentId}` : '/api/admin/items';
    const method = isUpdate ? 'PUT' : 'POST';

    const r = await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
    if (!r.ok) { const e = await r.json().catch(()=>({})); alert('Fehler beim Speichern: '+(e.error||r.status)); return; }
    if (!isUpdate) {
      const j = await r.json(); state.currentId = j.item; el('#f-item').value = j.item;
    }
    await fetchList();
    alert('Gespeichert.');
  }

  async function del(){
    if (!state.currentId) { alert('Kein Item geladen'); return; }
    if (!confirm('Item wirklich löschen?')) return;
    const r = await fetch(`/api/admin/items/${state.currentId}`, { method: 'DELETE' });
    if (!r.ok) { alert('Fehler beim Löschen'); return; }
    clearEditor(); await fetchList();
  }

  // UI wiring
  el('#btn-search').addEventListener('click', fetchList);
  el('#btn-new').addEventListener('click', () => clearEditor());
  el('#btn-add-opt').addEventListener('click', () => addLI('#f-options'));
  el('#btn-add-fb').addEventListener('click', () => addLI('#f-feedback'));
  el('#f-type').addEventListener('change', () => toggleMC());
  el('#item-form').addEventListener('submit', (ev) => { ev.preventDefault(); save(); });
  el('#btn-delete').addEventListener('click', del);

  bindToolbar();
  fetchList();
})();


// === DB SCHEMA ADDITIONS: server/db/schema.js ===============================
// Add these inside initSchema(db) after your existing views/tables
// (Idempotent: IF NOT EXISTS everywhere)

// Items master table (HTML fields stored as TEXT)
db.run(`
  CREATE TABLE IF NOT EXISTS items (
    item INTEGER PRIMARY KEY,
    type TEXT CHECK (type IN ('mc','open')) NOT NULL,
    que TEXT NOT NULL,
    que2a TEXT,
    que2b TEXT,
    explain TEXT,
    cor INTEGER, -- only for MC
    created_at TEXT DEFAULT (datetime('now')),
    updated_at TEXT DEFAULT (datetime('now'))
  );
`);

// MC options & feedback (arrays)
db.run(`
  CREATE TABLE IF NOT EXISTS mc_options (
    item INTEGER NOT NULL,
    idx  INTEGER NOT NULL,
    text TEXT NOT NULL,
    PRIMARY KEY (item, idx),
    FOREIGN KEY (item) REFERENCES items(item) ON DELETE CASCADE
  );
`);

db.run(`
  CREATE TABLE IF NOT EXISTS mc_feedback (
    item INTEGER NOT NULL,
    idx  INTEGER NOT NULL,
    text TEXT NOT NULL,
    PRIMARY KEY (item, idx),
    FOREIGN KEY (item) REFERENCES items(item) ON DELETE CASCADE
  );
`);

// OPEN accept/reject lists
db.run(`
  CREATE TABLE IF NOT EXISTS open_accept (
    item INTEGER NOT NULL,
    idx  INTEGER NOT NULL,
    text TEXT NOT NULL,
    PRIMARY KEY (item, idx),
    FOREIGN KEY (item) REFERENCES items(item) ON DELETE CASCADE
  );
`);

db.run(`
  CREATE TABLE IF NOT EXISTS open_reject (
    item INTEGER NOT NULL,
    idx  INTEGER NOT NULL,
    text TEXT NOT NULL,
    PRIMARY KEY (item, idx),
    FOREIGN KEY (item) REFERENCES items(item) ON DELETE CASCADE
  );
`);

// Helper triggers for updated_at
db.run(`
  CREATE TRIGGER IF NOT EXISTS trg_items_updated_at
  AFTER UPDATE ON items FOR EACH ROW
  BEGIN
    UPDATE items SET updated_at = datetime('now') WHERE item = NEW.item;
  END;
`);


// === NEW ROUTES: server/routes/item-crud.js =================================
import express from "express";

export default function itemCrudRouter(db) {
  const router = express.Router();

  // List (optional: ?q=search&limit=50&offset=0&type=mc|open)
  router.get('/api/items', (req, res) => {
    const { q = '', limit = 50, offset = 0, type } = req.query;
    const params = [];
    let where = 'WHERE 1=1';
    if (q) { where += ' AND (CAST(item AS TEXT) LIKE ? OR que LIKE ? OR que2a LIKE ? OR que2b LIKE ?)'; params.push(`%${q}%`,`%${q}%`,`%${q}%`,`%${q}%`); }
    if (type === 'mc' || type === 'open') { where += ' AND type = ?'; params.push(type); }
    const sql = `SELECT item, type, substr(que,1,120) AS que_snippet, updated_at FROM items ${where} ORDER BY item LIMIT ? OFFSET ?`;
    params.push(Number(limit)||50, Number(offset)||0);
    db.all(sql, params, (err, rows) => {
      if (err) return res.status(500).json({ error: 'DB error', detail: err.message });
      res.json(rows || []);
    });
  });

  // Read one (includes arrays)
  router.get('/api/items/:item', (req, res) => {
    const id = Number(req.params.item);
    if (!Number.isInteger(id)) return res.status(400).json({ error: 'Invalid item id' });
    const sqlItem = `SELECT * FROM items WHERE item = ?`;
    db.get(sqlItem, [id], (err, itemRow) => {
      if (err) return res.status(500).json({ error: 'DB error', detail: err.message });
      if (!itemRow) return res.status(404).json({ error: 'Not found' });

      const fetch = (table) => new Promise((resolve) => db.all(`SELECT idx, text FROM ${table} WHERE item = ? ORDER BY idx`, [id], (e, r) => resolve(r||[])));
      Promise.all([
        fetch('mc_options'),
        fetch('mc_feedback'),
        fetch('open_accept'),
        fetch('open_reject'),
      ]).then(([opt, fb, accept, reject]) => {
        res.json({ ...itemRow, opt: opt.map(o=>o.text), fb: fb.map(f=>f.text), accept: accept.map(a=>a.text), reject: reject.map(r=>r.text) });
      });
    });
  });

  // Upsert (create or replace) — expects a full item payload
  router.post('/api/items', (req, res) => {
    const p = req.body || {};
    // Basic validation
    if (!Number.isInteger(p.item)) return res.status(400).json({ error: 'item (int) required' });
    if (!['mc','open'].includes(p.type)) return res.status(400).json({ error: 'type must be mc|open' });
    if (typeof p.que !== 'string') return res.status(400).json({ error: 'que (HTML) required' });

    db.serialize(() => {
      db.run('BEGIN');

      // Upsert core
      db.run(`
        INSERT INTO items (item, type, que, que2a, que2b, explain, cor)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(item) DO UPDATE SET
          type=excluded.type, que=excluded.que, que2a=excluded.que2a,
          que2b=excluded.que2b, explain=excluded.explain, cor=excluded.cor
      `, [p.item, p.type, p.que || '', p.que2a || '', p.que2b || '', p.explain || '', (p.type==='mc' ? (Number.isInteger(p.cor)?p.cor:null) : null)], (err) => {
        if (err) { db.run('ROLLBACK'); return res.status(500).json({ error: 'DB upsert error', detail: err.message }); }

        // Clear arrays then insert provided values
        const clearAndInsert = (table, arr) => new Promise((resolve, reject) => {
          db.run(`DELETE FROM ${table} WHERE item = ?`, [p.item], (e) => {
            if (e) return reject(e);
            if (!Array.isArray(arr)) return resolve();
            const stmt = db.prepare(`INSERT INTO ${table} (item, idx, text) VALUES (?, ?, ?)`);
            arr.forEach((val, i) => stmt.run([p.item, i, String(val)]));
            stmt.finalize((e2) => e2 ? reject(e2) : resolve());
          });
        });

        Promise.all([
          clearAndInsert('mc_options', p.type==='mc' ? p.opt : []),
          clearAndInsert('mc_feedback', p.type==='mc' ? p.fb : []),
          clearAndInsert('open_accept', p.type==='open' ? p.accept : []),
          clearAndInsert('open_reject', p.type==='open' ? p.reject : []),
        ]).then(() => {
          db.run('COMMIT', (e3) => {
            if (e3) return res.status(500).json({ error: 'Commit error', detail: e3.message });
            res.json({ ok: true, item: p.item });
          });
        }).catch(e => { db.run('ROLLBACK'); res.status(500).json({ error: 'Array insert error', detail: e.message }); });
      });
    });
  });

  // Delete
  router.delete('/api/items/:item', (req, res) => {
    const id = Number(req.params.item);
    if (!Number.isInteger(id)) return res.status(400).json({ error: 'Invalid item id' });
    db.run('DELETE FROM items WHERE item = ?', [id], function(err){
      if (err) return res.status(500).json({ error: 'DB delete error', detail: err.message });
      res.json({ ok: true, deleted: this.changes });
    });
  });

  // Export as your current window.items format
  router.get('/api/items/export', (req, res) => {
    db.all('SELECT * FROM items ORDER BY item', [], async (err, rows) => {
      if (err) return res.status(500).json({ error: 'DB error', detail: err.message });

      const fetchArr = (table, item) => new Promise(r => db.all(`SELECT text FROM ${table} WHERE item=? ORDER BY idx`, [item], (e, rs) => r((rs||[]).map(x=>x.text))));

      const out = [];
      for (const it of rows) {
        const base = {
          item: it.item,
          type: it.type,
          que: it.que, que2a: it.que2a, que2b: it.que2b,
          explain: it.explain
        };
        if (it.type === 'mc') {
          const [opt, fb] = await Promise.all([fetchArr('mc_options', it.item), fetchArr('mc_feedback', it.item)]);
          out.push({ ...base, cor: it.cor ?? 0, opt, fb });
        } else {
          const [accept, reject] = await Promise.all([fetchArr('open_accept', it.item), fetchArr('open_reject', it.item)]);
          out.push({ ...base, accept, reject });
        }
      }
      res.json(out);
    });
  });

  return router;
}

